/* listfile class - a class for MVME formatted listfiles
 * This class will be used in the dumper-to-root project
 *
 * 
 * Copyright 2022 Justin Warren <jw402216@ohio.edu>
 * 
 * Listfile descriptors and format Copyright (C) 2017  Florian LÃ¼ke <f.lueke@mesytec.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

#include <cstdlib>
#include <cstdint>
#include <string>
#include <fstream>
#include <string>
#include <filesystem>
#include "dumper_constants.h"
#include "MVMEmodule.h"
#include "nlohmann/json.hpp"

namespace fs = std::filesystem;
using json = nlohmann::json;

#ifndef LISTFILE
#define LISTFILE

enum class PauseAction
{
    Pause = 0,
    Resume = 1,
};

enum class SectionType
{
    /* The config section contains the mvmecfg as a json string padded with
        * spaces to the next 32 bit boundary. If the config data size exceeds
        * the maximum section size multiple config sections will be written at
        * the start of the file. */
    SectionType_Config      = 0,

    /* Readout data generated by one VME Event. Contains module data
        * subsections. */
    SectionType_Event       = 1,

    /* Last section written to a listfile before closing the file. Contains
        * the current date and time as an ISO 8601 formatted string padded
        * with zeroes to the next 32-bit boundary (same as Timetick sections).
        * Should be used to verify that a file was correctly written and when
        * reading that all data has been read. */
    SectionType_End         = 2,

    /* Marker section written once at the start of a run and then once per
        * elapsed second. Contains the current date and time as an ISO 8601
        * formatted string padded with zeroes to the next 32-bit boundary. */
    SectionType_Timetick    = 3,

    /* Section marking the beginning and end of a user initiated pause.
        * Contains a single data word with value 0 for pause and value 1 for
        * resume. */
    SectionType_Pause       = 4,

    /* Max section type possible. */
    SectionType_Max         = 7
};


class listfile
{
    public:

        using enum PauseAction;
        using enum SectionType;

        listfile(); // default constructor for blank listfile()

        ~listfile(); // default destructor for listfile()

        int setTemplate(std::string template_filename); // sets the template from the provided file; 0 if okay, -1 if bad

        std::string getFilename() { return Filename; } // return Filename - available to set output file name
        uint32_t getVersion() { return Version; } // return Version
        std::string getFourCC() { return FourCC; } // return FourCC
        uint32_t getFirstSectionOffset() { return FirstSectionOffset; } // return FirstSectionOffset
        uint32_t getSectionMaxWords() { return SectionMaxWords;} // return SectionMaxWords
        uint32_t getSectionMaxSize() { return SectionMaxSize; } // return SectionMaxSize
        uint32_t getSectionTypeMask() { return SectionTypeMask; } // return SectionTypeMask
        uint32_t getSectionTypeShift() { return SectionTypeShift; }// return SectionTypeShift
        uint32_t getSectionSizeMask() { return SectionSizeMask; }// return SectionSizeMask
        uint32_t getSectionSizeShift() { return SectionSizeShift; } // return SectionSizeShift
        uint32_t getEventTypeMask() { return EventTypeMask;} // return EventTypeMask
        uint32_t getEventTypeShift() { return EventTypeShift; } // return EventTypeShift
        uint32_t getCrateIndexMask() { return CrateIndexMask; } // return CrateIndexMask
        uint32_t getCrateIndexShift() { return CrateIndexShift; }// return CrateIndexShift
        uint32_t getModuleTypeMask() { return ModuleTypeMask; } // return ModuleTypeMask
        uint32_t getModuleTypeShift() { return ModuleTypeShift; } // return ModuleTypeShift
        uint32_t getSubEventMaxWords() { return SubEventMaxWords; } // return SubEventMaxWords
        uint32_t getSubEventMaxSize() { return SubEventMaxSize; } // return SubEventMaxSize
        uint32_t getSubEventSizeMask() { return SubEventSizeMask; } // return SubEventSizeMask
        uint32_t getSubEventSizeShift() { return SubEventSizeShift; } // return SubEventSizeShift

        void printListfileSetting(); // pretty prints all listfile variables including filename


        void setFilename(std::string newFilename); // set Filename - available to set output file name

        std::map<uint32_t, std::tuple<std::string,VMEModuleType>> getTreename();  // return name of trees in file as a map
        void setTreenames(std::map<uint32_t, std::tuple<std::string,VMEModuleType>> treenames); // set map containing names of trees in file

        uint64_t getTimeticks(); // Get the number of time ticks in the file
        void setTimeticks(uint64_t numTimeticks); // Set the number of time ticks in the file


    private:
        uint32_t Version{0xffffffff}; // The version of the listfile
        std::string FourCC{""}; // The FourCC string
        uint32_t FirstSectionOffset{0}; // First section offset
        uint32_t SectionMaxWords{0}; // Maximum number of words in section
        uint32_t SectionMaxSize{0}; // Section maximum size in bytes
        uint32_t SectionTypeMask{0}; // Section type
        uint32_t SectionTypeShift{0}; // The shift for the SectionTypeMask
        uint32_t SectionSizeMask{0}; // Section size
        uint32_t SectionSizeShift{0}; // The shift for the SectionSizeMask
        uint32_t EventTypeMask{0}; // Event type
        uint32_t EventTypeShift{0}; // The shift for the EventTypeMask
        uint32_t CrateIndexMask{0}; // Crate index
        uint32_t CrateIndexShift{0}; // The shift for the CrateIndexMask
        uint32_t ModuleTypeMask{0};  // Module type
        uint32_t ModuleTypeShift{0}; // The shift for the ModuleTypeMask
        uint32_t SubEventMaxWords{0}; // Maximum words in subevent
        uint32_t SubEventMaxSize{0}; // Subevent maximum size in bytes
        uint32_t SubEventSizeMask{0}; // Subevent actual size mask
        uint32_t SubEventSizeShift{0}; // The shift for the SubEventSizeMask

        std::string Filename{""}; // The dir/name for the output file

        std::map<uint32_t, std::tuple<std::string,VMEModuleType>> RootTreeNames;

        uint64_t TimeTicks{0};

};

#endif